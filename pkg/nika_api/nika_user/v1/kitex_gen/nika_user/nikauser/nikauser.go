// Code generated by Kitex v0.2.0. DO NOT EDIT.

package nikauser

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"github.com/huolunl/nika-component-base/pkg/nika_api/nika_user/v1/kitex_gen/nika_user"
	"google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return nikaUserServiceInfo
}

var nikaUserServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "NikaUser"
	handlerType := (*nika_user.NikaUser)(nil)
	methods := map[string]kitex.MethodInfo{
		"Login":         kitex.NewMethodInfo(loginHandler, newLoginArgs, newLoginResult, false),
		"CreateTenant":  kitex.NewMethodInfo(createTenantHandler, newCreateTenantArgs, newCreateTenantResult, false),
		"CreateUser":    kitex.NewMethodInfo(createUserHandler, newCreateUserArgs, newCreateUserResult, false),
		"Authorization": kitex.NewMethodInfo(authorizationHandler, newAuthorizationArgs, newAuthorizationResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.2.0",
		Extra:           extra,
	}
	return svcInfo
}

func loginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_user.LoginRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_user.NikaUser).Login(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *LoginArgs:
		success, err := handler.(nika_user.NikaUser).Login(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*LoginResult)
		realResult.Success = success
	}
	return nil
}
func newLoginArgs() interface{} {
	return &LoginArgs{}
}

func newLoginResult() interface{} {
	return &LoginResult{}
}

type LoginArgs struct {
	Req *nika_user.LoginRequest
}

func (p *LoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in LoginArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *LoginArgs) Unmarshal(in []byte) error {
	msg := new(nika_user.LoginRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var LoginArgs_Req_DEFAULT *nika_user.LoginRequest

func (p *LoginArgs) GetReq() *nika_user.LoginRequest {
	if !p.IsSetReq() {
		return LoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *LoginArgs) IsSetReq() bool {
	return p.Req != nil
}

type LoginResult struct {
	Success *nika_user.LoginResponse
}

var LoginResult_Success_DEFAULT *nika_user.LoginResponse

func (p *LoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in LoginResult")
	}
	return proto.Marshal(p.Success)
}

func (p *LoginResult) Unmarshal(in []byte) error {
	msg := new(nika_user.LoginResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *LoginResult) GetSuccess() *nika_user.LoginResponse {
	if !p.IsSetSuccess() {
		return LoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *LoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_user.LoginResponse)
}

func (p *LoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func createTenantHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_user.CreateTenantRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_user.NikaUser).CreateTenant(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateTenantArgs:
		success, err := handler.(nika_user.NikaUser).CreateTenant(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateTenantResult)
		realResult.Success = success
	}
	return nil
}
func newCreateTenantArgs() interface{} {
	return &CreateTenantArgs{}
}

func newCreateTenantResult() interface{} {
	return &CreateTenantResult{}
}

type CreateTenantArgs struct {
	Req *nika_user.CreateTenantRequest
}

func (p *CreateTenantArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateTenantArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateTenantArgs) Unmarshal(in []byte) error {
	msg := new(nika_user.CreateTenantRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateTenantArgs_Req_DEFAULT *nika_user.CreateTenantRequest

func (p *CreateTenantArgs) GetReq() *nika_user.CreateTenantRequest {
	if !p.IsSetReq() {
		return CreateTenantArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateTenantArgs) IsSetReq() bool {
	return p.Req != nil
}

type CreateTenantResult struct {
	Success *nika_user.CreateTenantResponse
}

var CreateTenantResult_Success_DEFAULT *nika_user.CreateTenantResponse

func (p *CreateTenantResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateTenantResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateTenantResult) Unmarshal(in []byte) error {
	msg := new(nika_user.CreateTenantResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateTenantResult) GetSuccess() *nika_user.CreateTenantResponse {
	if !p.IsSetSuccess() {
		return CreateTenantResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateTenantResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_user.CreateTenantResponse)
}

func (p *CreateTenantResult) IsSetSuccess() bool {
	return p.Success != nil
}

func createUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_user.CreateUserRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_user.NikaUser).CreateUser(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateUserArgs:
		success, err := handler.(nika_user.NikaUser).CreateUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateUserResult)
		realResult.Success = success
	}
	return nil
}
func newCreateUserArgs() interface{} {
	return &CreateUserArgs{}
}

func newCreateUserResult() interface{} {
	return &CreateUserResult{}
}

type CreateUserArgs struct {
	Req *nika_user.CreateUserRequest
}

func (p *CreateUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateUserArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateUserArgs) Unmarshal(in []byte) error {
	msg := new(nika_user.CreateUserRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateUserArgs_Req_DEFAULT *nika_user.CreateUserRequest

func (p *CreateUserArgs) GetReq() *nika_user.CreateUserRequest {
	if !p.IsSetReq() {
		return CreateUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateUserArgs) IsSetReq() bool {
	return p.Req != nil
}

type CreateUserResult struct {
	Success *nika_user.CreateUserResponse
}

var CreateUserResult_Success_DEFAULT *nika_user.CreateUserResponse

func (p *CreateUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateUserResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateUserResult) Unmarshal(in []byte) error {
	msg := new(nika_user.CreateUserResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateUserResult) GetSuccess() *nika_user.CreateUserResponse {
	if !p.IsSetSuccess() {
		return CreateUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_user.CreateUserResponse)
}

func (p *CreateUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func authorizationHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_user.AuthorizationRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_user.NikaUser).Authorization(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AuthorizationArgs:
		success, err := handler.(nika_user.NikaUser).Authorization(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AuthorizationResult)
		realResult.Success = success
	}
	return nil
}
func newAuthorizationArgs() interface{} {
	return &AuthorizationArgs{}
}

func newAuthorizationResult() interface{} {
	return &AuthorizationResult{}
}

type AuthorizationArgs struct {
	Req *nika_user.AuthorizationRequest
}

func (p *AuthorizationArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in AuthorizationArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *AuthorizationArgs) Unmarshal(in []byte) error {
	msg := new(nika_user.AuthorizationRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AuthorizationArgs_Req_DEFAULT *nika_user.AuthorizationRequest

func (p *AuthorizationArgs) GetReq() *nika_user.AuthorizationRequest {
	if !p.IsSetReq() {
		return AuthorizationArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AuthorizationArgs) IsSetReq() bool {
	return p.Req != nil
}

type AuthorizationResult struct {
	Success *nika_user.AuthorizationResponse
}

var AuthorizationResult_Success_DEFAULT *nika_user.AuthorizationResponse

func (p *AuthorizationResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in AuthorizationResult")
	}
	return proto.Marshal(p.Success)
}

func (p *AuthorizationResult) Unmarshal(in []byte) error {
	msg := new(nika_user.AuthorizationResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AuthorizationResult) GetSuccess() *nika_user.AuthorizationResponse {
	if !p.IsSetSuccess() {
		return AuthorizationResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AuthorizationResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_user.AuthorizationResponse)
}

func (p *AuthorizationResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) Login(ctx context.Context, Req *nika_user.LoginRequest) (r *nika_user.LoginResponse, err error) {
	var _args LoginArgs
	_args.Req = Req
	var _result LoginResult
	if err = p.c.Call(ctx, "Login", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateTenant(ctx context.Context, Req *nika_user.CreateTenantRequest) (r *nika_user.CreateTenantResponse, err error) {
	var _args CreateTenantArgs
	_args.Req = Req
	var _result CreateTenantResult
	if err = p.c.Call(ctx, "CreateTenant", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateUser(ctx context.Context, Req *nika_user.CreateUserRequest) (r *nika_user.CreateUserResponse, err error) {
	var _args CreateUserArgs
	_args.Req = Req
	var _result CreateUserResult
	if err = p.c.Call(ctx, "CreateUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Authorization(ctx context.Context, Req *nika_user.AuthorizationRequest) (r *nika_user.AuthorizationResponse, err error) {
	var _args AuthorizationArgs
	_args.Req = Req
	var _result AuthorizationResult
	if err = p.c.Call(ctx, "Authorization", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
