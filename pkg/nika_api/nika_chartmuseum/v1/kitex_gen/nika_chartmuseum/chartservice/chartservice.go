// Code generated by Kitex v0.2.1. DO NOT EDIT.

package chartservice

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"github.com/huolunl/nika-component-base/pkg/nika_api/nika_chartmuseum/v1/kitex_gen/nika_chartmuseum"
	"google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return chartServiceServiceInfo
}

var chartServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "ChartService"
	handlerType := (*nika_chartmuseum.ChartService)(nil)
	methods := map[string]kitex.MethodInfo{
		"ListChart":                kitex.NewMethodInfo(listChartHandler, newListChartArgs, newListChartResult, false),
		"DeleteChart":              kitex.NewMethodInfo(deleteChartHandler, newDeleteChartArgs, newDeleteChartResult, false),
		"UploadProvenanceFile":     kitex.NewMethodInfo(uploadProvenanceFileHandler, newUploadProvenanceFileArgs, newUploadProvenanceFileResult, false),
		"GetChartByName":           kitex.NewMethodInfo(getChartByNameHandler, newGetChartByNameArgs, newGetChartByNameResult, false),
		"PageChartList":            kitex.NewMethodInfo(pageChartListHandler, newPageChartListArgs, newPageChartListResult, false),
		"UploadChart":              kitex.NewMethodInfo(uploadChartHandler, newUploadChartArgs, newUploadChartResult, false),
		"DescribeChartVersion":     kitex.NewMethodInfo(describeChartVersionHandler, newDescribeChartVersionArgs, newDescribeChartVersionResult, false),
		"CheckChartIsExist":        kitex.NewMethodInfo(checkChartIsExistHandler, newCheckChartIsExistArgs, newCheckChartIsExistResult, false),
		"CheckChartVersionIsExist": kitex.NewMethodInfo(checkChartVersionIsExistHandler, newCheckChartVersionIsExistArgs, newCheckChartVersionIsExistResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.2.1",
		Extra:           extra,
	}
	return svcInfo
}

func listChartHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_chartmuseum.ListChartRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_chartmuseum.ChartService).ListChart(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ListChartArgs:
		success, err := handler.(nika_chartmuseum.ChartService).ListChart(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListChartResult)
		realResult.Success = success
	}
	return nil
}
func newListChartArgs() interface{} {
	return &ListChartArgs{}
}

func newListChartResult() interface{} {
	return &ListChartResult{}
}

type ListChartArgs struct {
	Req *nika_chartmuseum.ListChartRequest
}

func (p *ListChartArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ListChartArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ListChartArgs) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.ListChartRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListChartArgs_Req_DEFAULT *nika_chartmuseum.ListChartRequest

func (p *ListChartArgs) GetReq() *nika_chartmuseum.ListChartRequest {
	if !p.IsSetReq() {
		return ListChartArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListChartArgs) IsSetReq() bool {
	return p.Req != nil
}

type ListChartResult struct {
	Success *nika_chartmuseum.ListChartResponse
}

var ListChartResult_Success_DEFAULT *nika_chartmuseum.ListChartResponse

func (p *ListChartResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ListChartResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ListChartResult) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.ListChartResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListChartResult) GetSuccess() *nika_chartmuseum.ListChartResponse {
	if !p.IsSetSuccess() {
		return ListChartResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListChartResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_chartmuseum.ListChartResponse)
}

func (p *ListChartResult) IsSetSuccess() bool {
	return p.Success != nil
}

func deleteChartHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_chartmuseum.DeleteChartRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_chartmuseum.ChartService).DeleteChart(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteChartArgs:
		success, err := handler.(nika_chartmuseum.ChartService).DeleteChart(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteChartResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteChartArgs() interface{} {
	return &DeleteChartArgs{}
}

func newDeleteChartResult() interface{} {
	return &DeleteChartResult{}
}

type DeleteChartArgs struct {
	Req *nika_chartmuseum.DeleteChartRequest
}

func (p *DeleteChartArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeleteChartArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteChartArgs) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.DeleteChartRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteChartArgs_Req_DEFAULT *nika_chartmuseum.DeleteChartRequest

func (p *DeleteChartArgs) GetReq() *nika_chartmuseum.DeleteChartRequest {
	if !p.IsSetReq() {
		return DeleteChartArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteChartArgs) IsSetReq() bool {
	return p.Req != nil
}

type DeleteChartResult struct {
	Success *nika_chartmuseum.DeleteChartResponse
}

var DeleteChartResult_Success_DEFAULT *nika_chartmuseum.DeleteChartResponse

func (p *DeleteChartResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeleteChartResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteChartResult) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.DeleteChartResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteChartResult) GetSuccess() *nika_chartmuseum.DeleteChartResponse {
	if !p.IsSetSuccess() {
		return DeleteChartResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteChartResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_chartmuseum.DeleteChartResponse)
}

func (p *DeleteChartResult) IsSetSuccess() bool {
	return p.Success != nil
}

func uploadProvenanceFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_chartmuseum.UploadProvenanceFileRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_chartmuseum.ChartService).UploadProvenanceFile(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UploadProvenanceFileArgs:
		success, err := handler.(nika_chartmuseum.ChartService).UploadProvenanceFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UploadProvenanceFileResult)
		realResult.Success = success
	}
	return nil
}
func newUploadProvenanceFileArgs() interface{} {
	return &UploadProvenanceFileArgs{}
}

func newUploadProvenanceFileResult() interface{} {
	return &UploadProvenanceFileResult{}
}

type UploadProvenanceFileArgs struct {
	Req *nika_chartmuseum.UploadProvenanceFileRequest
}

func (p *UploadProvenanceFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UploadProvenanceFileArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UploadProvenanceFileArgs) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.UploadProvenanceFileRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UploadProvenanceFileArgs_Req_DEFAULT *nika_chartmuseum.UploadProvenanceFileRequest

func (p *UploadProvenanceFileArgs) GetReq() *nika_chartmuseum.UploadProvenanceFileRequest {
	if !p.IsSetReq() {
		return UploadProvenanceFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UploadProvenanceFileArgs) IsSetReq() bool {
	return p.Req != nil
}

type UploadProvenanceFileResult struct {
	Success *nika_chartmuseum.UploadProvenanceFileResponse
}

var UploadProvenanceFileResult_Success_DEFAULT *nika_chartmuseum.UploadProvenanceFileResponse

func (p *UploadProvenanceFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UploadProvenanceFileResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UploadProvenanceFileResult) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.UploadProvenanceFileResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UploadProvenanceFileResult) GetSuccess() *nika_chartmuseum.UploadProvenanceFileResponse {
	if !p.IsSetSuccess() {
		return UploadProvenanceFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UploadProvenanceFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_chartmuseum.UploadProvenanceFileResponse)
}

func (p *UploadProvenanceFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getChartByNameHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_chartmuseum.GetChartByNameRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_chartmuseum.ChartService).GetChartByName(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetChartByNameArgs:
		success, err := handler.(nika_chartmuseum.ChartService).GetChartByName(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetChartByNameResult)
		realResult.Success = success
	}
	return nil
}
func newGetChartByNameArgs() interface{} {
	return &GetChartByNameArgs{}
}

func newGetChartByNameResult() interface{} {
	return &GetChartByNameResult{}
}

type GetChartByNameArgs struct {
	Req *nika_chartmuseum.GetChartByNameRequest
}

func (p *GetChartByNameArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetChartByNameArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetChartByNameArgs) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.GetChartByNameRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetChartByNameArgs_Req_DEFAULT *nika_chartmuseum.GetChartByNameRequest

func (p *GetChartByNameArgs) GetReq() *nika_chartmuseum.GetChartByNameRequest {
	if !p.IsSetReq() {
		return GetChartByNameArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetChartByNameArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetChartByNameResult struct {
	Success *nika_chartmuseum.GetChartByNameResponse
}

var GetChartByNameResult_Success_DEFAULT *nika_chartmuseum.GetChartByNameResponse

func (p *GetChartByNameResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetChartByNameResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetChartByNameResult) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.GetChartByNameResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetChartByNameResult) GetSuccess() *nika_chartmuseum.GetChartByNameResponse {
	if !p.IsSetSuccess() {
		return GetChartByNameResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetChartByNameResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_chartmuseum.GetChartByNameResponse)
}

func (p *GetChartByNameResult) IsSetSuccess() bool {
	return p.Success != nil
}

func pageChartListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_chartmuseum.PageChartListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_chartmuseum.ChartService).PageChartList(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *PageChartListArgs:
		success, err := handler.(nika_chartmuseum.ChartService).PageChartList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PageChartListResult)
		realResult.Success = success
	}
	return nil
}
func newPageChartListArgs() interface{} {
	return &PageChartListArgs{}
}

func newPageChartListResult() interface{} {
	return &PageChartListResult{}
}

type PageChartListArgs struct {
	Req *nika_chartmuseum.PageChartListRequest
}

func (p *PageChartListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in PageChartListArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *PageChartListArgs) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.PageChartListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PageChartListArgs_Req_DEFAULT *nika_chartmuseum.PageChartListRequest

func (p *PageChartListArgs) GetReq() *nika_chartmuseum.PageChartListRequest {
	if !p.IsSetReq() {
		return PageChartListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PageChartListArgs) IsSetReq() bool {
	return p.Req != nil
}

type PageChartListResult struct {
	Success *nika_chartmuseum.PageChartListResponse
}

var PageChartListResult_Success_DEFAULT *nika_chartmuseum.PageChartListResponse

func (p *PageChartListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in PageChartListResult")
	}
	return proto.Marshal(p.Success)
}

func (p *PageChartListResult) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.PageChartListResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PageChartListResult) GetSuccess() *nika_chartmuseum.PageChartListResponse {
	if !p.IsSetSuccess() {
		return PageChartListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PageChartListResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_chartmuseum.PageChartListResponse)
}

func (p *PageChartListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func uploadChartHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_chartmuseum.UploadChartRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_chartmuseum.ChartService).UploadChart(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UploadChartArgs:
		success, err := handler.(nika_chartmuseum.ChartService).UploadChart(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UploadChartResult)
		realResult.Success = success
	}
	return nil
}
func newUploadChartArgs() interface{} {
	return &UploadChartArgs{}
}

func newUploadChartResult() interface{} {
	return &UploadChartResult{}
}

type UploadChartArgs struct {
	Req *nika_chartmuseum.UploadChartRequest
}

func (p *UploadChartArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UploadChartArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UploadChartArgs) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.UploadChartRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UploadChartArgs_Req_DEFAULT *nika_chartmuseum.UploadChartRequest

func (p *UploadChartArgs) GetReq() *nika_chartmuseum.UploadChartRequest {
	if !p.IsSetReq() {
		return UploadChartArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UploadChartArgs) IsSetReq() bool {
	return p.Req != nil
}

type UploadChartResult struct {
	Success *nika_chartmuseum.UploadChartResponse
}

var UploadChartResult_Success_DEFAULT *nika_chartmuseum.UploadChartResponse

func (p *UploadChartResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UploadChartResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UploadChartResult) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.UploadChartResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UploadChartResult) GetSuccess() *nika_chartmuseum.UploadChartResponse {
	if !p.IsSetSuccess() {
		return UploadChartResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UploadChartResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_chartmuseum.UploadChartResponse)
}

func (p *UploadChartResult) IsSetSuccess() bool {
	return p.Success != nil
}

func describeChartVersionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_chartmuseum.DescribeChartVersionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_chartmuseum.ChartService).DescribeChartVersion(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DescribeChartVersionArgs:
		success, err := handler.(nika_chartmuseum.ChartService).DescribeChartVersion(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DescribeChartVersionResult)
		realResult.Success = success
	}
	return nil
}
func newDescribeChartVersionArgs() interface{} {
	return &DescribeChartVersionArgs{}
}

func newDescribeChartVersionResult() interface{} {
	return &DescribeChartVersionResult{}
}

type DescribeChartVersionArgs struct {
	Req *nika_chartmuseum.DescribeChartVersionRequest
}

func (p *DescribeChartVersionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DescribeChartVersionArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DescribeChartVersionArgs) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.DescribeChartVersionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DescribeChartVersionArgs_Req_DEFAULT *nika_chartmuseum.DescribeChartVersionRequest

func (p *DescribeChartVersionArgs) GetReq() *nika_chartmuseum.DescribeChartVersionRequest {
	if !p.IsSetReq() {
		return DescribeChartVersionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DescribeChartVersionArgs) IsSetReq() bool {
	return p.Req != nil
}

type DescribeChartVersionResult struct {
	Success *nika_chartmuseum.DescribeChartVersionResponse
}

var DescribeChartVersionResult_Success_DEFAULT *nika_chartmuseum.DescribeChartVersionResponse

func (p *DescribeChartVersionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DescribeChartVersionResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DescribeChartVersionResult) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.DescribeChartVersionResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DescribeChartVersionResult) GetSuccess() *nika_chartmuseum.DescribeChartVersionResponse {
	if !p.IsSetSuccess() {
		return DescribeChartVersionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DescribeChartVersionResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_chartmuseum.DescribeChartVersionResponse)
}

func (p *DescribeChartVersionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func checkChartIsExistHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_chartmuseum.CheckChartIsExistRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_chartmuseum.ChartService).CheckChartIsExist(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CheckChartIsExistArgs:
		success, err := handler.(nika_chartmuseum.ChartService).CheckChartIsExist(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CheckChartIsExistResult)
		realResult.Success = success
	}
	return nil
}
func newCheckChartIsExistArgs() interface{} {
	return &CheckChartIsExistArgs{}
}

func newCheckChartIsExistResult() interface{} {
	return &CheckChartIsExistResult{}
}

type CheckChartIsExistArgs struct {
	Req *nika_chartmuseum.CheckChartIsExistRequest
}

func (p *CheckChartIsExistArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CheckChartIsExistArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CheckChartIsExistArgs) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.CheckChartIsExistRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CheckChartIsExistArgs_Req_DEFAULT *nika_chartmuseum.CheckChartIsExistRequest

func (p *CheckChartIsExistArgs) GetReq() *nika_chartmuseum.CheckChartIsExistRequest {
	if !p.IsSetReq() {
		return CheckChartIsExistArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CheckChartIsExistArgs) IsSetReq() bool {
	return p.Req != nil
}

type CheckChartIsExistResult struct {
	Success *nika_chartmuseum.CheckChartIsExistResponse
}

var CheckChartIsExistResult_Success_DEFAULT *nika_chartmuseum.CheckChartIsExistResponse

func (p *CheckChartIsExistResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CheckChartIsExistResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CheckChartIsExistResult) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.CheckChartIsExistResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CheckChartIsExistResult) GetSuccess() *nika_chartmuseum.CheckChartIsExistResponse {
	if !p.IsSetSuccess() {
		return CheckChartIsExistResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CheckChartIsExistResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_chartmuseum.CheckChartIsExistResponse)
}

func (p *CheckChartIsExistResult) IsSetSuccess() bool {
	return p.Success != nil
}

func checkChartVersionIsExistHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(nika_chartmuseum.CheckChartVersionIsExistRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(nika_chartmuseum.ChartService).CheckChartVersionIsExist(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CheckChartVersionIsExistArgs:
		success, err := handler.(nika_chartmuseum.ChartService).CheckChartVersionIsExist(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CheckChartVersionIsExistResult)
		realResult.Success = success
	}
	return nil
}
func newCheckChartVersionIsExistArgs() interface{} {
	return &CheckChartVersionIsExistArgs{}
}

func newCheckChartVersionIsExistResult() interface{} {
	return &CheckChartVersionIsExistResult{}
}

type CheckChartVersionIsExistArgs struct {
	Req *nika_chartmuseum.CheckChartVersionIsExistRequest
}

func (p *CheckChartVersionIsExistArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CheckChartVersionIsExistArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CheckChartVersionIsExistArgs) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.CheckChartVersionIsExistRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CheckChartVersionIsExistArgs_Req_DEFAULT *nika_chartmuseum.CheckChartVersionIsExistRequest

func (p *CheckChartVersionIsExistArgs) GetReq() *nika_chartmuseum.CheckChartVersionIsExistRequest {
	if !p.IsSetReq() {
		return CheckChartVersionIsExistArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CheckChartVersionIsExistArgs) IsSetReq() bool {
	return p.Req != nil
}

type CheckChartVersionIsExistResult struct {
	Success *nika_chartmuseum.CheckChartVersionIsExistResponse
}

var CheckChartVersionIsExistResult_Success_DEFAULT *nika_chartmuseum.CheckChartVersionIsExistResponse

func (p *CheckChartVersionIsExistResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CheckChartVersionIsExistResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CheckChartVersionIsExistResult) Unmarshal(in []byte) error {
	msg := new(nika_chartmuseum.CheckChartVersionIsExistResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CheckChartVersionIsExistResult) GetSuccess() *nika_chartmuseum.CheckChartVersionIsExistResponse {
	if !p.IsSetSuccess() {
		return CheckChartVersionIsExistResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CheckChartVersionIsExistResult) SetSuccess(x interface{}) {
	p.Success = x.(*nika_chartmuseum.CheckChartVersionIsExistResponse)
}

func (p *CheckChartVersionIsExistResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) ListChart(ctx context.Context, Req *nika_chartmuseum.ListChartRequest) (r *nika_chartmuseum.ListChartResponse, err error) {
	var _args ListChartArgs
	_args.Req = Req
	var _result ListChartResult
	if err = p.c.Call(ctx, "ListChart", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteChart(ctx context.Context, Req *nika_chartmuseum.DeleteChartRequest) (r *nika_chartmuseum.DeleteChartResponse, err error) {
	var _args DeleteChartArgs
	_args.Req = Req
	var _result DeleteChartResult
	if err = p.c.Call(ctx, "DeleteChart", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UploadProvenanceFile(ctx context.Context, Req *nika_chartmuseum.UploadProvenanceFileRequest) (r *nika_chartmuseum.UploadProvenanceFileResponse, err error) {
	var _args UploadProvenanceFileArgs
	_args.Req = Req
	var _result UploadProvenanceFileResult
	if err = p.c.Call(ctx, "UploadProvenanceFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetChartByName(ctx context.Context, Req *nika_chartmuseum.GetChartByNameRequest) (r *nika_chartmuseum.GetChartByNameResponse, err error) {
	var _args GetChartByNameArgs
	_args.Req = Req
	var _result GetChartByNameResult
	if err = p.c.Call(ctx, "GetChartByName", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) PageChartList(ctx context.Context, Req *nika_chartmuseum.PageChartListRequest) (r *nika_chartmuseum.PageChartListResponse, err error) {
	var _args PageChartListArgs
	_args.Req = Req
	var _result PageChartListResult
	if err = p.c.Call(ctx, "PageChartList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UploadChart(ctx context.Context, Req *nika_chartmuseum.UploadChartRequest) (r *nika_chartmuseum.UploadChartResponse, err error) {
	var _args UploadChartArgs
	_args.Req = Req
	var _result UploadChartResult
	if err = p.c.Call(ctx, "UploadChart", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DescribeChartVersion(ctx context.Context, Req *nika_chartmuseum.DescribeChartVersionRequest) (r *nika_chartmuseum.DescribeChartVersionResponse, err error) {
	var _args DescribeChartVersionArgs
	_args.Req = Req
	var _result DescribeChartVersionResult
	if err = p.c.Call(ctx, "DescribeChartVersion", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CheckChartIsExist(ctx context.Context, Req *nika_chartmuseum.CheckChartIsExistRequest) (r *nika_chartmuseum.CheckChartIsExistResponse, err error) {
	var _args CheckChartIsExistArgs
	_args.Req = Req
	var _result CheckChartIsExistResult
	if err = p.c.Call(ctx, "CheckChartIsExist", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CheckChartVersionIsExist(ctx context.Context, Req *nika_chartmuseum.CheckChartVersionIsExistRequest) (r *nika_chartmuseum.CheckChartVersionIsExistResponse, err error) {
	var _args CheckChartVersionIsExistArgs
	_args.Req = Req
	var _result CheckChartVersionIsExistResult
	if err = p.c.Call(ctx, "CheckChartVersionIsExist", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
